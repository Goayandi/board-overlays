From 558b730fe0f2fcf0c8995dfc32bc99ff1c95dc24 Mon Sep 17 00:00:00 2001
From: Sean Paul <seanpaul@chromium.org>
Date: Mon, 12 May 2014 16:17:07 -0400
Subject: [PATCH 17/18] drm: Fix up the atomic legacy paths so they work

BUG=chromium:336809
TEST=Tested on snow & peppy

Signed-off-by: Sean Paul <seanpaul@chromium.org>
Change-Id: Icd864ac52da9c973202f3ac4629824ef5eec2ac9
---
 drivers/gpu/drm/drm_atomic.c |  4 ++++
 drivers/gpu/drm/drm_crtc.c   | 12 +++++++++---
 include/drm/drm_crtc.h       |  1 +
 3 files changed, 14 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/drm_atomic.c b/drivers/gpu/drm/drm_atomic.c
index 71a5493..86df30a 100644
--- a/drivers/gpu/drm/drm_atomic.c
+++ b/drivers/gpu/drm/drm_atomic.c
@@ -599,6 +599,7 @@ swap_crtc_state(struct drm_crtc *crtc, struct drm_atomic_state *a)
 	/* clear transient state (only valid during atomic update): */
 	cstate->set_config = false;
 	cstate->connectors_change = false;
+	cstate->commit_state = false;
 
 	swap(crtc->state, a->cstates[crtc->id]);
 	crtc->base.propvals = &crtc->state->propvals;
@@ -673,6 +674,9 @@ commit_crtc_state(struct drm_crtc *crtc,
 			drm_atomic_get_plane_state(crtc->primary, cstate->state);
 	int ret = -EINVAL;
 
+	if (!cstate->commit_state)
+		return 0;
+
 	if (cstate->set_config)
 		return set_config(crtc, cstate);
 
diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
index 8738926..665f10e 100644
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@ -751,7 +751,7 @@ int drm_crtc_init_with_planes(struct drm_device *dev, struct drm_crtc *crtc,
 	crtc->base.propvals = &crtc->state->propvals;
 
 	list_add_tail(&crtc->head, &dev->mode_config.crtc_list);
-	dev->mode_config.num_crtc++;
+	crtc->id = dev->mode_config.num_crtc++;
 
 	crtc->primary = primary;
 	if (primary)
@@ -866,7 +866,7 @@ static int check_connectors(struct drm_crtc *crtc, void *state, bool fix,
 		if (ocrtc == crtc)
 			continue;
 
-		ostate = drm_atomic_get_crtc_state(crtc, state);
+		ostate = drm_atomic_get_crtc_state(ocrtc, state);
 		if (IS_ERR(ostate))
 			return PTR_ERR(ostate);
 
@@ -895,7 +895,6 @@ retry:
 			return -EINVAL;
 		}
 	}
-
 	return 0;
 }
 
@@ -917,6 +916,10 @@ int drm_crtc_check_state(struct drm_crtc *crtc,
 	if (!(fb && state->mode_valid))
 		return 0;
 
+	/* We're not committing this state, ignore */
+	if (!state->commit_state)
+		return 0;
+
 	hdisplay = state->mode.hdisplay;
 	vdisplay = state->mode.vdisplay;
 
@@ -982,6 +985,7 @@ int drm_crtc_set_property(struct drm_crtc *crtc,
 	/* grab primary plane state now, to ensure locks are held, etc. */
 	drm_atomic_get_plane_state(crtc->primary, state->state);
 
+	state->commit_state = true;
 	drm_object_property_set_value(&crtc->base,
 			&state->propvals, property, value, blob_data);
 
@@ -993,6 +997,7 @@ int drm_crtc_set_property(struct drm_crtc *crtc,
 			/* check size: */
 			if (value < sizeof(struct drm_mode_modeinfo))
 				return -EINVAL;
+
 			state->mode = *(struct drm_mode_modeinfo *)blob_data;
 			state->mode_valid = true;
 		}
@@ -1431,6 +1436,7 @@ int drm_plane_set_property(struct drm_plane *plane,
 	} else if (property == config->prop_crtc_id) {
 		struct drm_mode_object *obj = drm_property_get_obj(property, value);
 		struct drm_crtc *crtc = obj ? obj_to_crtc(obj) : NULL;
+
 		/* take the lock of the incoming crtc as well, moving
 		 * plane between crtcs is synchronized on both incoming
 		 * and outgoing crtc.
diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 39cd72c..fc42ff4 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -481,6 +481,7 @@ struct drm_crtc_state {
 	/* transient state, only valid during atomic operation: */
 	bool set_config        : 1;
 	bool connectors_change : 1;
+	bool commit_state      : 1;
 
 	uint8_t num_connector_ids;
 	uint32_t *connector_ids;
-- 
1.8.3.2

