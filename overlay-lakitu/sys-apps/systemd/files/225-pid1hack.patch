Copyright 2015 The Chromium OS Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.

We run systemd not as PID1 as it's supposed to be. systemd disables some of its
features when pid is not 1. This patch fixes this. With this patch systemd will:
 - do initialization as MANAGER_SYSTEM
 - mount filesystems. Most importantly it will mount cgroups.
 - Enable /run/systemd/private - a unix socket that allows systemctl communicate
   with systemd without D-Bus.
 - zero umask
 - change log functions so they behave the same way without PID1

diff --git a/src/basic/log.c b/src/basic/log.c
index b96afc4..1d70190 100644
--- a/src/basic/log.c
+++ b/src/basic/log.c
@@ -67,7 +67,7 @@ void log_close_console(void) {
         if (console_fd < 0)
                 return;
 
-        if (getpid() == 1) {
+        if (true /*getpid() == 1*/) {
                 if (console_fd >= 3)
                         safe_close(console_fd);
 
@@ -80,7 +80,7 @@ static int log_open_console(void) {
         if (console_fd >= 0)
                 return 0;
 
-        if (getpid() == 1) {
+        if (true /*getpid() == 1*/) {
                 console_fd = open_terminal("/dev/console", O_WRONLY|O_NOCTTY|O_CLOEXEC);
                 if (console_fd < 0)
                         return console_fd;
@@ -123,7 +123,7 @@ static int create_log_socket(int type) {
         /* We need a blocking fd here since we'd otherwise lose
         messages way too early. However, let's not hang forever in the
         unlikely case of a deadlock. */
-        if (getpid() == 1)
+        if (true /*getpid() == 1*/)
                 timeval_store(&tv, 10 * USEC_PER_MSEC);
         else
                 timeval_store(&tv, 10 * USEC_PER_SEC);
@@ -229,7 +229,7 @@ int log_open(void) {
         }
 
         if ((log_target != LOG_TARGET_AUTO && log_target != LOG_TARGET_SAFE) ||
-            getpid() == 1 ||
+            true /*getpid() == 1*/ ||
             isatty(STDERR_FILENO) <= 0) {
 
                 if (log_target == LOG_TARGET_AUTO ||
@@ -348,7 +348,7 @@ static int write_to_console(
 
         if (writev(console_fd, iovec, n) < 0) {
 
-                if (errno == EIO && getpid() == 1) {
+                if (errno == EIO && true /*getpid() == 1*/) {
 
                         /* If somebody tried to kick us from our
                          * console tty (via vhangup() or suchlike),
@@ -1118,7 +1118,7 @@ int log_syntax_internal(
                 r = log_struct_internal(
                                 level, error,
                                 file, line, func,
-                                getpid() == 1 ? "UNIT=%s" : "USER_UNIT=%s", unit,
+                                true /*getpid() == 1*/ ? "UNIT=%s" : "USER_UNIT=%s", unit,
                                 LOG_MESSAGE_ID(SD_MESSAGE_INVALID_CONFIGURATION),
                                 "CONFIG_FILE=%s", config_file,
                                 "CONFIG_LINE=%u", config_line,
diff --git a/src/basic/log.h b/src/basic/log.h
index 569762d..b9c8dca 100644
--- a/src/basic/log.h
+++ b/src/basic/log.h
@@ -171,7 +171,7 @@ void log_assert_failed_return(
 #define log_notice(...)    log_full(LOG_NOTICE,  __VA_ARGS__)
 #define log_warning(...)   log_full(LOG_WARNING, __VA_ARGS__)
 #define log_error(...)     log_full(LOG_ERR,     __VA_ARGS__)
-#define log_emergency(...) log_full(getpid() == 1 ? LOG_EMERG : LOG_ERR, __VA_ARGS__)
+#define log_emergency(...) log_full(LOG_EMERG, __VA_ARGS__)
 
 /* Logging triggered by an errno-like error */
 #define log_debug_errno(error, ...)     log_full_errno(LOG_DEBUG,   error, __VA_ARGS__)
@@ -179,7 +179,7 @@ void log_assert_failed_return(
 #define log_notice_errno(error, ...)    log_full_errno(LOG_NOTICE,  error, __VA_ARGS__)
 #define log_warning_errno(error, ...)   log_full_errno(LOG_WARNING, error, __VA_ARGS__)
 #define log_error_errno(error, ...)     log_full_errno(LOG_ERR,     error, __VA_ARGS__)
-#define log_emergency_errno(error, ...) log_full_errno(getpid() == 1 ? LOG_EMERG : LOG_ERR, error, __VA_ARGS__)
+#define log_emergency_errno(error, ...) log_full_errno(LOG_EMERG, error, __VA_ARGS__)
 
 #ifdef LOG_TRACE
 #  define log_trace(...) log_debug(__VA_ARGS__)
diff --git a/src/core/dbus.c b/src/core/dbus.c
index 44bf5ca..6a3a187 100644
--- a/src/core/dbus.c
+++ b/src/core/dbus.c
@@ -933,11 +933,6 @@ static int bus_init_private(Manager *m) {
                 return 0;
 
         if (m->running_as == MANAGER_SYSTEM) {
-
-                /* We want the private bus only when running as init */
-                if (getpid() != 1)
-                        return 0;
-
                 strcpy(sa.un.sun_path, "/run/systemd/private");
                 salen = offsetof(union sockaddr_union, un.sun_path) + strlen("/run/systemd/private");
         } else {
diff --git a/src/core/main.c b/src/core/main.c
index 87b97aa..1f4b3b3 100644
--- a/src/core/main.c
+++ b/src/core/main.c
@@ -1290,10 +1290,9 @@ int main(int argc, char *argv[]) {
         log_set_upgrade_syslog_to_journal(true);
 
         /* Disable the umask logic */
-        if (getpid() == 1)
-                umask(0);
+        umask(0);
 
-        if (getpid() == 1 && detect_container(NULL) <= 0) {
+        if (true && detect_container(NULL) <= 0) {
 
                 /* Running outside of a container as PID 1 */
                 arg_running_as = MANAGER_SYSTEM;
@@ -1368,7 +1367,7 @@ int main(int argc, char *argv[]) {
                  * might redirect output elsewhere. */
                 log_set_target(LOG_TARGET_JOURNAL_OR_KMSG);
 
-        } else if (getpid() == 1) {
+        } else if (/* getpid() == 1 */ true) {
                 /* Running inside a container, as PID 1 */
                 arg_running_as = MANAGER_SYSTEM;
                 log_set_target(LOG_TARGET_CONSOLE);
@@ -1417,11 +1416,11 @@ int main(int argc, char *argv[]) {
                 if (!skip_setup)
                         kmod_setup();
 
-                r = mount_setup(loaded_policy);
-                if (r < 0) {
-                        error_message = "Failed to mount API filesystems";
-                        goto finish;
-                }
+        }
+        r = mount_setup(loaded_policy);
+        if (r < 0) {
+                error_message = "Failed to mount API filesystems";
+                goto finish;
         }
 
         /* Reset all signal handlers. */
@@ -1541,11 +1540,10 @@ int main(int argc, char *argv[]) {
          * kernel. */
         if (getpid() == 1) {
                 install_crash_handler();
-
-                r = mount_cgroup_controllers(arg_join_controllers);
-                if (r < 0)
-                        goto finish;
         }
+        r = mount_cgroup_controllers(arg_join_controllers);
+        if (r < 0)
+                goto finish;
 
         if (arg_running_as == MANAGER_SYSTEM) {
                 const char *virtualization = NULL;
