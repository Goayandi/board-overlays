From 7bb2fe78482d26f70a1c128f93e1b6fe135edfc9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?St=C3=A9phane=20Marchesin?= <marcheu@chromium.org>
Date: Tue, 15 Sep 2015 15:45:03 -0700
Subject: [PATCH 8/8] HACK: tegra dmabuf hacks

Change-Id: I2a8efd21b4daf79b28b820758963400c919a3d65
---
 .../config/armel/chromeos-tegra.flavour.config     |   2 +-
 drivers/gpu/drm/tegra/gem.c                        |   5 +-
 drivers/video/tegra/host/dmabuf.c                  | 121 +++++++++++++++++----
 drivers/video/tegra/host/dmabuf.h                  |   5 +
 drivers/video/tegra/host/nvhost_memmgr.c           |  36 +++++-
 drivers/video/tegra/host/nvhost_memmgr.h           |  14 ++-
 drivers/video/tegra/host/nvmap.c                   |   4 -
 drivers/video/tegra/nvmap/nvmap.c                  |   2 +-
 drivers/video/tegra/nvmap/nvmap_dmabuf.c           |  42 +++++--
 drivers/video/tegra/nvmap/nvmap_handle.c           |   9 ++
 include/linux/nvmap.h                              |   2 +
 11 files changed, 197 insertions(+), 45 deletions(-)

diff --git a/chromeos/config/armel/chromeos-tegra.flavour.config b/chromeos/config/armel/chromeos-tegra.flavour.config
index c615c8e..06334b1 100644
--- a/chromeos/config/armel/chromeos-tegra.flavour.config
+++ b/chromeos/config/armel/chromeos-tegra.flavour.config
@@ -114,7 +114,7 @@ CONFIG_NVMAP_PAGE_POOLS_INIT_FILLUP=y
 CONFIG_NVMAP_PAGE_POOLS_INIT_FILLUP_SIZE=0x64
 CONFIG_NVMAP_PAGE_POOL_SIZE=0x0
 # CONFIG_NVMAP_USE_CMA_FOR_CARVEOUT is not set
-CONFIG_NVMAP_USE_FD_FOR_HANDLE=y
+# CONFIG_NVMAP_USE_FD_FOR_HANDLE is not set
 # CONFIG_NVMAP_VPR is not set
 CONFIG_PAGE_OFFSET=0xC0000000
 CONFIG_PHYS_ADDR_T_64BIT=y
diff --git a/drivers/gpu/drm/tegra/gem.c b/drivers/gpu/drm/tegra/gem.c
index 00fcc00..ad34e19 100644
--- a/drivers/gpu/drm/tegra/gem.c
+++ b/drivers/gpu/drm/tegra/gem.c
@@ -638,8 +638,11 @@ struct dma_buf *tegra_gem_prime_export(struct drm_device *drm,
 				       struct drm_gem_object *gem,
 				       int flags)
 {
-	return dma_buf_export(gem, &tegra_gem_prime_dmabuf_ops, gem->size,
+	struct dma_buf *buf =  dma_buf_export(gem, &tegra_gem_prime_dmabuf_ops, gem->size,
 			      flags);
+
+	printk(KERN_ERR"export dmabuf %p from tegra drm\n",buf);
+	return buf;
 }
 
 struct drm_gem_object *tegra_gem_prime_import(struct drm_device *drm,
diff --git a/drivers/video/tegra/host/dmabuf.c b/drivers/video/tegra/host/dmabuf.c
index 62e5331..17639ee 100644
--- a/drivers/video/tegra/host/dmabuf.c
+++ b/drivers/video/tegra/host/dmabuf.c
@@ -20,12 +20,21 @@
 
 #include <linux/dma-buf.h>
 #include <linux/nvhost.h>
+#include <linux/nvmap.h>
+#include <linux/slab.h>
 #include "chip_support.h"
+#include "nvhost_allocator.h"
 #include "nvhost_memmgr.h"
+#include "../nvmap/nvmap_ioctl.h"
+
+struct nvhost_dmabuf_data {
+	struct nvhost_comptags comptags;
+	struct nvhost_allocator *comptag_allocator; // TODO implement freeing
+};
 
 static inline struct dma_buf_attachment *to_dmabuf_att(struct mem_handle *h)
 {
-	return (struct dma_buf_attachment *)(((uintptr_t)h) & ~0x3);
+	return (struct dma_buf_attachment *)h;
 }
 
 static inline struct dma_buf *to_dmabuf(struct mem_handle *h)
@@ -33,13 +42,10 @@ static inline struct dma_buf *to_dmabuf(struct mem_handle *h)
 	return to_dmabuf_att(h)->dmabuf;
 }
 
-static inline int to_dmabuf_fd(ulong id)
-{
-	return nvhost_memmgr_id(id) >> 2;
-}
 struct mem_handle *nvhost_dmabuf_alloc(size_t size, size_t align, int flags)
 {
 	/* TODO: Add allocation via DMA Mapping API */
+	WARN_ON(1);
 	return NULL;
 }
 
@@ -53,6 +59,15 @@ void nvhost_dmabuf_put(struct mem_handle *handle)
 
 struct sg_table *nvhost_dmabuf_pin(struct mem_handle *handle)
 {
+	struct dma_buf_attachment *attach = (struct dma_buf_attachment*)handle;
+	struct nvhost_dmabuf_data *priv;
+
+	WARN_ON(attach->priv);
+
+	/* Allocate priv struct */
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	attach->priv = priv;
+
 	return dma_buf_map_attachment(to_dmabuf_att(handle),
 				DMA_BIDIRECTIONAL);
 }
@@ -86,26 +101,92 @@ void nvhost_dmabuf_kunmap(struct mem_handle *handle, unsigned int pagenum,
 
 struct mem_handle *nvhost_dmabuf_get(ulong id, struct platform_device *dev)
 {
-	struct mem_handle *h;
-	struct dma_buf *buf;
-
-	buf = dma_buf_get(to_dmabuf_fd(id));
-	if (IS_ERR(buf))
-		return (struct mem_handle *)buf;
-	else {
-		h = (struct mem_handle *)dma_buf_attach(buf, &dev->dev);
-		if (IS_ERR(h)) {
-			dma_buf_put(buf);
-			return (struct mem_handle *)h;
-		}
-	}
+	struct dma_buf_attachment *attach;
 
-	return (struct mem_handle *) ((uintptr_t)h | mem_mgr_type_dmabuf);
+	attach = nvmap_get_dmabuf_attachment((struct nvmap_handle *)id);
+
+	return (struct mem_handle *)attach;
 }
 
+#if 0
+static void delete_priv(void *_priv)
+{
+	struct nvhost_dmabuf_data *priv = _priv;
+
+	WARN_ON(!priv);
+
+	if (priv->comptags.lines) {
+		BUG_ON(!priv->comptag_allocator);
+		priv->comptag_allocator->free(priv->comptag_allocator,
+					      priv->comptags.offset,
+					      priv->comptags.lines);
+	}
+	kfree(priv);
+}
+#endif
+
 int nvhost_dmabuf_get_param(struct mem_mgr *memmgr, struct mem_handle *handle,
 			    u32 param, u64 *result)
 {
-	/* TBD: find a way to associate size, kind, etc */
+	struct dma_buf_attachment *attach = (struct dma_buf_attachment*)handle;
+
+	switch(param)
+	{
+		case NVMAP_HANDLE_PARAM_SIZE:
+			*result = attach->dmabuf->size;
+			return 0;
+		case NVMAP_HANDLE_PARAM_ALIGNMENT:
+			if (attach->dmabuf->size & (128 * 1024 - 1))
+				*result = 4096;
+			else
+				*result = 128 * 1024;
+			return 0;
+		case NVMAP_HANDLE_PARAM_BASE:
+			*result = 0;
+			return 0;
+		case NVMAP_HANDLE_PARAM_HEAP:
+			*result = NVMAP_HEAP_IOVMM;
+			return 0;
+		case NVMAP_HANDLE_PARAM_KIND:
+			*result = 0xdb; // gmmu_pte_kind_c32_2cra_v();
+			return 0;
+	}
+
+	printk(KERN_ERR"Unimplemented parameter %d handle %p\n",param,handle);
 	return -EINVAL;
 }
+
+void nvhost_dmabuf_get_comptags(struct mem_handle *handle,
+				struct nvhost_comptags *comptags)
+{
+	struct dma_buf_attachment *attach = (struct dma_buf_attachment*)handle;
+	struct nvhost_dmabuf_data *priv;
+
+	WARN_ON(!attach->priv);
+
+	priv = attach->priv;
+	*comptags = priv->comptags;
+}
+
+int nvhost_dmabuf_alloc_comptags(struct mem_handle *handle,
+				 struct nvhost_allocator *allocator,
+				 int lines)
+{
+	struct dma_buf_attachment *attach = (struct dma_buf_attachment*)handle;
+	struct nvhost_dmabuf_data *priv;
+	u32 offset = 0;
+	int err;
+
+	BUG_ON(!lines);
+	WARN_ON(!attach->priv);
+	priv = attach->priv;
+
+	/* store the allocator so we can use it when we free the ctags */
+	priv->comptag_allocator = allocator;
+	err = allocator->alloc(allocator, &offset, lines);
+	if (!err) {
+		priv->comptags.lines = lines;
+		priv->comptags.offset = offset;
+	}
+	return err;
+}
diff --git a/drivers/video/tegra/host/dmabuf.h b/drivers/video/tegra/host/dmabuf.h
index 2646184..85a280e 100644
--- a/drivers/video/tegra/host/dmabuf.h
+++ b/drivers/video/tegra/host/dmabuf.h
@@ -43,4 +43,9 @@ void nvhost_dmabuf_kunmap(struct mem_handle *handle, unsigned int pagenum,
 struct mem_handle *nvhost_dmabuf_get(ulong id, struct platform_device *dev);
 int nvhost_dmabuf_get_param(struct mem_mgr *memmgr, struct mem_handle *handle,
 			   u32 param, u64 *result);
+void nvhost_dmabuf_get_comptags(struct mem_handle *handle,
+				struct nvhost_comptags *comptags);
+int nvhost_dmabuf_alloc_comptags(struct mem_handle *handle,
+				 struct nvhost_allocator *allocator,
+				 int lines);
 #endif
diff --git a/drivers/video/tegra/host/nvhost_memmgr.c b/drivers/video/tegra/host/nvhost_memmgr.c
index 6fb668c..71f4bc1 100644
--- a/drivers/video/tegra/host/nvhost_memmgr.c
+++ b/drivers/video/tegra/host/nvhost_memmgr.c
@@ -119,6 +119,7 @@ struct mem_handle *nvhost_memmgr_get(struct mem_mgr *mgr,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 
@@ -139,6 +140,7 @@ void nvhost_memmgr_put(struct mem_mgr *mgr, struct mem_handle *handle)
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 }
@@ -158,6 +160,7 @@ struct sg_table *nvhost_memmgr_pin(struct mem_mgr *mgr,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		return 0;
 		break;
 	}
@@ -179,6 +182,7 @@ void nvhost_memmgr_unpin(struct mem_mgr *mgr,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 }
@@ -197,6 +201,7 @@ void *nvhost_memmgr_mmap(struct mem_handle *handle)
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		return 0;
 		break;
 	}
@@ -216,6 +221,7 @@ void nvhost_memmgr_munmap(struct mem_handle *handle, void *addr)
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 }
@@ -242,6 +248,7 @@ int nvhost_memmgr_get_param(struct mem_mgr *mem_mgr,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 	return -EINVAL;
@@ -262,6 +269,7 @@ void *nvhost_memmgr_kmap(struct mem_handle *handle, unsigned int pagenum)
 #endif
 	default:
 		return 0;
+		WARN_ON(1);
 		break;
 	}
 }
@@ -281,6 +289,7 @@ void nvhost_memmgr_kunmap(struct mem_handle *handle, unsigned int pagenum,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 }
@@ -300,6 +309,7 @@ u32 nvhost_memmgr_handle_to_id(struct mem_handle *handle)
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 
@@ -344,6 +354,7 @@ void nvhost_memmgr_free_sg_table(struct mem_mgr *mgr,
 		break;
 #endif
 	default:
+		WARN_ON(1);
 		break;
 	}
 	return;
@@ -353,11 +364,20 @@ void nvhost_memmgr_get_comptags(struct mem_handle *mem,
 				struct nvhost_comptags *comptags)
 {
 #ifdef CONFIG_TEGRA_GRHOST_USE_NVMAP
-	return nvhost_nvmap_get_comptags(mem, comptags);
+	switch (nvhost_memmgr_type((ulong)mem)) {
+	case mem_mgr_type_nvmap:
+		nvhost_nvmap_get_comptags(mem, comptags);
+		return;
 #endif
 #ifdef CONFIG_TEGRA_GRHOST_USE_DMABUF
-	WARN_ON(1);
+	case mem_mgr_type_dmabuf:
+		nvhost_dmabuf_get_comptags(mem, comptags);
+		return;
 #endif
+	default:
+		WARN_ON(1);
+		return;
+	}
 }
 
 int nvhost_memmgr_alloc_comptags(struct mem_handle *mem,
@@ -365,12 +385,18 @@ int nvhost_memmgr_alloc_comptags(struct mem_handle *mem,
 				 int lines)
 {
 #ifdef CONFIG_TEGRA_GRHOST_USE_NVMAP
-	return nvhost_nvmap_alloc_comptags(mem, allocator, lines);
+	switch (nvhost_memmgr_type((ulong)mem)) {
+	case mem_mgr_type_nvmap:
+		return nvhost_nvmap_alloc_comptags(mem, allocator, lines);
 #endif
 #ifdef CONFIG_TEGRA_GRHOST_USE_DMABUF
-	WARN_ON(1);
-	return 0;
+	case mem_mgr_type_dmabuf:
+		return nvhost_dmabuf_alloc_comptags(mem, allocator, lines);
 #endif
+	default:
+		WARN_ON(1);
+		return 0;
+	}
 }
 
 int nvhost_memmgr_init(struct nvhost_chip_support *chip)
diff --git a/drivers/video/tegra/host/nvhost_memmgr.h b/drivers/video/tegra/host/nvhost_memmgr.h
index 8e65151..14eebb8 100644
--- a/drivers/video/tegra/host/nvhost_memmgr.h
+++ b/drivers/video/tegra/host/nvhost_memmgr.h
@@ -21,6 +21,7 @@
 #ifndef _NVHOST_MEM_MGR_H_
 #define _NVHOST_MEM_MGR_H_
 
+#include <linux/dma-buf.h>
 #include <linux/dma-mapping.h>
 #include <linux/scatterlist.h>
 
@@ -87,7 +88,18 @@ struct sg_table *nvhost_memmgr_sg_table(struct mem_mgr *mgr,
 		struct mem_handle *handle);
 void nvhost_memmgr_free_sg_table(struct mem_mgr *mgr,
 		struct mem_handle *handle, struct sg_table *sgt);
-static inline int nvhost_memmgr_type(ulong id) { return id & MEMMGR_TYPE_MASK; }
+extern struct dma_buf_ops nvmap_dma_buf_ops;
+static inline int nvhost_memmgr_type(ulong id) {
+	struct dma_buf* db = (struct dma_buf*)id;
+	if (id < 4096)
+		return mem_mgr_type_dmabuf;
+
+	if (db->ops == &nvmap_dma_buf_ops)
+		return mem_mgr_type_nvmap;
+	else
+		return mem_mgr_type_dmabuf;
+}
+
 static inline int nvhost_memmgr_id(ulong id) { return id & MEMMGR_ID_MASK; }
 u32 nvhost_memmgr_handle_to_id(struct mem_handle *handle);
 
diff --git a/drivers/video/tegra/host/nvmap.c b/drivers/video/tegra/host/nvmap.c
index fb10ee6..5333a36 100644
--- a/drivers/video/tegra/host/nvmap.c
+++ b/drivers/video/tegra/host/nvmap.c
@@ -260,12 +260,8 @@ void nvhost_nvmap_kunmap(struct mem_handle *handle, unsigned int pagenum,
 struct mem_handle *nvhost_nvmap_get(struct mem_mgr *mgr,
 		ulong id, struct platform_device *dev)
 {
-#ifdef CONFIG_NVMAP_USE_FD_FOR_HANDLE
-	return (struct mem_handle *)dma_buf_get(id);
-#else
 	return (struct mem_handle *)
 		nvmap_dmabuf_export((struct nvmap_client *)mgr, id);
-#endif
 }
 
 int nvhost_nvmap_get_param(struct mem_mgr *mgr, struct mem_handle *handle,
diff --git a/drivers/video/tegra/nvmap/nvmap.c b/drivers/video/tegra/nvmap/nvmap.c
index 66f0902..66f7529 100644
--- a/drivers/video/tegra/nvmap/nvmap.c
+++ b/drivers/video/tegra/nvmap/nvmap.c
@@ -447,7 +447,7 @@ void nvmap_handle_put(struct nvmap_handle *h)
 {
 	int cnt;
 
-	if (WARN_ON(!virt_addr_valid(h)))
+	if (((unsigned long)h < 4096) || WARN_ON(!virt_addr_valid(h)))
 		return;
 	cnt = atomic_dec_return(&h->ref);
 
diff --git a/drivers/video/tegra/nvmap/nvmap_dmabuf.c b/drivers/video/tegra/nvmap/nvmap_dmabuf.c
index 8f09b02..65fcc64 100644
--- a/drivers/video/tegra/nvmap/nvmap_dmabuf.c
+++ b/drivers/video/tegra/nvmap/nvmap_dmabuf.c
@@ -164,6 +164,7 @@ static void nvmap_dmabuf_detach(struct dma_buf *dmabuf,
  * Add this sgt to the stash - should be called when the SGT's ref count hits
  * 0.
  */
+/*
 static void __nvmap_dmabuf_add_stash(struct nvmap_handle_sgt *nvmap_sgt)
 {
 	pr_debug("Adding mapping to stash.\n");
@@ -173,7 +174,7 @@ static void __nvmap_dmabuf_add_stash(struct nvmap_handle_sgt *nvmap_sgt)
 	stash_stat_inc(stashed_maps);
 	stash_stat_add_iova(nvmap_sgt->owner->handle);
 }
-
+*/
 /*
  * Make sure this mapping is no longer stashed - this corresponds to a "hit". If
  * the mapping is not stashed this is just a no-op.
@@ -290,11 +291,11 @@ static void __nvmap_dmabuf_stash_sgt_locked(struct dma_buf_attachment *attach,
 			 * If we get here, the ref count is zero. Stash the
 			 * mapping.
 			 */
-#ifdef CONFIG_NVMAP_DMABUF_STASH
-			__nvmap_dmabuf_add_stash(nvmap_sgt);
-#else
+//#ifdef CONFIG_NVMAP_DMABUF_STASH
+//			__nvmap_dmabuf_add_stash(nvmap_sgt);
+//#else
 			__nvmap_dmabuf_free_sgt_locked(nvmap_sgt);
-#endif
+//#endif
 			goto done;
 		}
 	}
@@ -388,10 +389,10 @@ static struct sg_table *nvmap_dmabuf_map_dma_buf(
 	}
 
 cache_hit:
-#ifdef CONFIG_NVMAP_DMABUF_STASH
-	BUG_ON(attach->priv && attach->priv != sgt);
-#endif
-	attach->priv = sgt;
+//#ifdef CONFIG_NVMAP_DMABUF_STASH
+//	BUG_ON(attach->priv && attach->priv != sgt);
+//#endif
+//	attach->priv = sgt;
 	mutex_unlock(&info->maps_lock);
 	return sgt;
 
@@ -520,7 +521,7 @@ static void nvmap_dmabuf_vunmap(struct dma_buf *dmabuf, void *vaddr)
 	__nvmap_munmap(info->handle, vaddr);
 }
 
-static struct dma_buf_ops nvmap_dma_buf_ops = {
+struct dma_buf_ops nvmap_dma_buf_ops = {
 	.attach		= nvmap_dmabuf_attach,
 	.detach		= nvmap_dmabuf_detach,
 	.map_dma_buf	= nvmap_dmabuf_map_dma_buf,
@@ -683,14 +684,25 @@ ulong nvmap_get_id_from_dmabuf_fd(struct nvmap_client *client, int fd)
 	struct dma_buf *dmabuf;
 	struct nvmap_handle_info *info;
 
+	/* FIXME this whole function is leaking the handle info struct. */
+
 	dmabuf = dma_buf_get(fd);
 	if (IS_ERR(dmabuf))
 		return PTR_ERR(dmabuf);
 	if (dmabuf->ops == &nvmap_dma_buf_ops) {
+		/* Self-imported dmabuf, we can just get a ref and move on */
 		info = dmabuf->priv;
 		id = (ulong) info->handle;
 		if (!nvmap_handle_get(info->handle))
 			id = -EINVAL;
+	} else {
+		/* Foreign dmabuf, need to import */
+		struct nvmap_handle_ref *ref;
+		ref = nvmap_create_handle(client, dmabuf->size);
+		if (!nvmap_handle_get(ref->handle))
+			id = -EINVAL;
+		else
+			id = (ulong) (ref->handle);
 	}
 	dma_buf_put(dmabuf);
 	return id;
@@ -761,6 +773,7 @@ void nvmap_set_dmabuf_private(struct dma_buf *dmabuf, void *priv,
 	if (WARN_ON(!virt_addr_valid(dmabuf)))
 		return;
 
+
 	info = dmabuf->priv;
 	info->handle->nvhost_priv = priv;
 	info->handle->nvhost_priv_delete = delete;
@@ -774,8 +787,13 @@ void *nvmap_get_dmabuf_private(struct dma_buf *dmabuf)
 	if (WARN_ON(!virt_addr_valid(dmabuf)))
 		return ERR_PTR(-EINVAL);
 
-	info = dmabuf->priv;
-	priv = info->handle->nvhost_priv;
+	if (dmabuf->ops == &nvmap_dma_buf_ops) {
+		info = dmabuf->priv;
+		priv = info->handle->nvhost_priv;
+	} else {
+		WARN_ON(1);
+		return NULL;
+	}
 	return priv;
 }
 
diff --git a/drivers/video/tegra/nvmap/nvmap_handle.c b/drivers/video/tegra/nvmap/nvmap_handle.c
index 02db3ed..38f5500 100644
--- a/drivers/video/tegra/nvmap/nvmap_handle.c
+++ b/drivers/video/tegra/nvmap/nvmap_handle.c
@@ -1111,6 +1111,10 @@ struct nvmap_handle_ref *nvmap_create_handle_from_fd(
 	id = nvmap_get_id_from_dmabuf_fd(client, fd);
 	if (IS_ERR_VALUE(id))
 		return ERR_PTR(id);
+
+	/* give it some IOVM backing */
+	alloc_handle(client, (struct nvmap_handle *)id, NVMAP_HEAP_IOVMM);
+
 	ref = nvmap_duplicate_handle_id(client, id, 1);
 	nvmap_handle_put((struct nvmap_handle *)id);
 	return ref;
@@ -1293,3 +1297,8 @@ int nvmap_get_handle_param(struct nvmap_client *client,
 
 	return __nvmap_get_handle_param(client, ref->handle, param, result);
 }
+
+struct dma_buf_attachment *nvmap_get_dmabuf_attachment(struct nvmap_handle *h)
+{
+	return h->attachment;
+}
diff --git a/include/linux/nvmap.h b/include/linux/nvmap.h
index a4970ee..673d2f6 100644
--- a/include/linux/nvmap.h
+++ b/include/linux/nvmap.h
@@ -86,6 +86,8 @@ void *nvmap_get_dmabuf_private(struct dma_buf *dmabuf);
 
 int nvmap_get_dmabuf_param(struct dma_buf *dmabuf, u32 param, u64 *result);
 
+struct dma_buf_attachment *nvmap_get_dmabuf_attachment(struct nvmap_handle *h);
+
 #ifdef CONFIG_NVMAP_PAGE_POOLS
 ulong nvmap_page_pool_get_unused_pages(void);
 #else
-- 
2.6.0.rc2.230.g3dd15c0

