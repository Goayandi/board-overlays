From 73799887c94a0ab642b379f47e56687f88aac826 Mon Sep 17 00:00:00 2001
From: Sean Paul <seanpaul@chromium.org>
Date: Wed, 14 May 2014 12:07:29 -0400
Subject: [PATCH 02/18] drm/exynos: Add a hack to appease userspace & atomic
 helpers

This patch adds a small hack to the plane initialization of the
exynos planes such that the "default window" has a possible_crtcs
of 0 and an overlay plane type. This ensures that userspace will
not select the plane for cursor use, but allows the planes to be
included in the drm layer plane loops which disable planes.

This will be removed once we no longer use the primary plane helpers
and properly implement it ourselves.

BUG=chromium:336809
TEST=Tested on snow & peppy

Change-Id: I0f22326935572617259e7f3b6a0e5c6bafd492b2
---
 drivers/gpu/drm/exynos/exynos_drm_fimd.c | 15 ++++++++++++---
 drivers/gpu/drm/exynos/exynos_drm_vidi.c | 15 ++++++++++++---
 drivers/gpu/drm/exynos/exynos_mixer.c    | 15 ++++++++++++---
 3 files changed, 36 insertions(+), 9 deletions(-)

diff --git a/drivers/gpu/drm/exynos/exynos_drm_fimd.c b/drivers/gpu/drm/exynos/exynos_drm_fimd.c
index 5e97c6b..5e04ee3 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_fimd.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_fimd.c
@@ -495,10 +495,19 @@ static int fimd_mgr_initialize(void *in_ctx, struct drm_crtc *crtc, int pipe)
 	for (i = 0; i < FIMD_WIN_NR; i++) {
 		struct exynos_drm_plane *exynos_plane = &ctx->planes[i];
 
+		/*
+		 * TODO: There's a small hack here which sets possible_crtcs to
+		 *	 0 for the default win. This will prevent userspace from
+		 *	 choosing it for display. It's necessary until we
+		 *	 properly implement it as the primary plane. For now,
+		 *	 we'll let drm treat it as an overlay plane so it's
+		 *	 disabled at the right times (notably when we restore
+		 *	 fbdev mode).
+		 */
 		ret = drm_plane_init(ctx->drm_dev, &exynos_plane->base,
-				1 << ctx->pipe, &fimd_plane_funcs,
-				plane_formats, ARRAY_SIZE(plane_formats),
-				i == ctx->default_win ? true : false);
+			i == ctx->default_win ?	0 :1 << ctx->pipe,
+			&fimd_plane_funcs, plane_formats,
+			ARRAY_SIZE(plane_formats), false);
 		if (ret) {
 			DRM_ERROR("Init plane %d failed (ret=%d)\n", i, ret);
 			goto err;
diff --git a/drivers/gpu/drm/exynos/exynos_drm_vidi.c b/drivers/gpu/drm/exynos/exynos_drm_vidi.c
index b87cee6..7f48657 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_vidi.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_vidi.c
@@ -291,10 +291,19 @@ static int vidi_mgr_initialize(void *in_ctx, struct drm_crtc *crtc, int pipe)
 		struct exynos_drm_plane *exynos_plane = &ctx->planes[i];
 		struct drm_plane *plane = &exynos_plane->base;
 
-		ret = drm_plane_init(ctx->drm_dev, plane, 1 << ctx->pipe,
+		/*
+		 * TODO: There's a small hack here which sets possible_crtcs to
+		 *	 0 for the default win. This will prevent userspace from
+		 *	 choosing it for display. It's necessary until we
+		 *	 properly implement it as the primary plane. For now,
+		 *	 we'll let drm treat it as an overlay plane so it's
+		 *	 disabled at the right times (notably when we restore
+		 *	 fbdev mode).
+		 */
+		ret = drm_plane_init(ctx->drm_dev, plane,
+				i == ctx->default_win ? 0 : 1 << ctx->pipe,
 				&vidi_plane_funcs, plane_formats,
-				ARRAY_SIZE(plane_formats),
-				i == ctx->default_win ? true : false);
+				ARRAY_SIZE(plane_formats), false);
 		if (ret) {
 			DRM_ERROR("Init plane %d failed (ret=%d)\n", i, ret);
 			goto err;
diff --git a/drivers/gpu/drm/exynos/exynos_mixer.c b/drivers/gpu/drm/exynos/exynos_mixer.c
index 3a759e6..7e7366f 100644
--- a/drivers/gpu/drm/exynos/exynos_mixer.c
+++ b/drivers/gpu/drm/exynos/exynos_mixer.c
@@ -1092,10 +1092,19 @@ static int mixer_initialize(void *ctx, struct drm_crtc *crtc, int pipe)
 		struct drm_plane *plane = &mixer_ctx->planes[i].base;
 		struct exynos_drm_plane *exynos_plane = to_exynos_plane(plane);
 
+		/*
+		 * TODO: There's a small hack here which sets possible_crtcs to
+		 *	 0 for the default win. This will prevent userspace from
+		 *	 choosing it for display. It's necessary until we
+		 *	 properly implement it as the primary plane. For now,
+		 *	 we'll let drm treat it as an overlay plane so it's
+		 *	 disabled at the right times (notably when we restore
+		 *	 fbdev mode).
+		 */
 		ret = drm_plane_init(mixer_ctx->drm_dev, plane,
-				1 << mixer_ctx->pipe, &mixer_plane_funcs,
-				plane_formats, ARRAY_SIZE(plane_formats),
-				i == MIXER_DEFAULT_WIN ? true : false);
+			i == MIXER_DEFAULT_WIN ? 0 : 1 << mixer_ctx->pipe,
+			&mixer_plane_funcs, plane_formats,
+			ARRAY_SIZE(plane_formats), false);
 		if (ret) {
 			DRM_ERROR("Init plane %d failed (ret=%d)\n", i, ret);
 			goto err;
-- 
1.8.3.2

